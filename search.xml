<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BFS和DFS学习笔记</title>
      <link href="/posts/8cf1478.html"/>
      <url>/posts/8cf1478.html</url>
      
        <content type="html"><![CDATA[<h1 id="BFS和DFS学习笔记"><a href="#BFS和DFS学习笔记" class="headerlink" title="BFS和DFS学习笔记"></a>BFS和DFS学习笔记</h1><p><em>上课上完要交代码，结果根本写不出来，必须狠狠学一波了</em></p><h2 id="什么是BFS和DFS"><a href="#什么是BFS和DFS" class="headerlink" title="什么是BFS和DFS"></a>什么是BFS和DFS</h2><p><strong>BFS</strong>：广度优先搜索<br><strong>DFS</strong>：深度优先搜索</p><h2 id="BFS和DFS的基本原理"><a href="#BFS和DFS的基本原理" class="headerlink" title="BFS和DFS的基本原理"></a>BFS和DFS的基本原理</h2><p>BFS使用<strong>队列</strong>来实现节点遍历，按层次遍历<br>DFS使用<strong>栈</strong>或<strong>递归</strong>来实现节点遍历，深度优先遍历</p><h2 id="DFS的实现"><a href="#DFS的实现" class="headerlink" title="DFS的实现"></a>DFS的实现</h2><h3 id="DFS的基本思路"><a href="#DFS的基本思路" class="headerlink" title="DFS的基本思路"></a>DFS的基本思路</h3><p><strong>DFS</strong>全称为“深度优先搜索”，它是一种用于遍历或搜索树或图的算法。其基本思路是从图的一个顶点开始，<strong>深度优先地遍历</strong>整个图。具体来说，DFS从某个节点出发，沿着一条路径一直往下走，直到不能再走为止，然后<strong>回溯</strong>到上一个节点，再沿着另一条路径往下走，直到遍历完整张图为止。</p><p>DFS的基本思路可以用以下几个步骤概括：</p><ol><li>从起点出发，将起点<strong>标记为已访问</strong>。</li><li><strong>找</strong>到起点的所有<strong>未被访问</strong>的邻居节点，并对每个邻居节点进行如下操作：<ol><li>标记该邻居节点为已访问。</li><li>以该邻居节点为起点递归进行DFS。</li></ol></li><li>如果所有邻居节点都被访问过，则回溯到上一个节点，重复步骤2，直到所有节点都被访问。</li></ol><p>DFS的基本思路比较简单，但要正确实现DFS还需要注意一些细节问题，比如如何储存图、如何避免重复访问等。接下来将详细介绍DFS的实现过程。</p><h3 id="递归实现DFS"><a href="#递归实现DFS" class="headerlink" title="递归实现DFS"></a>递归实现DFS</h3><p><strong>实现步骤：</strong></p><ol><li><p>定义一个函数dfs，接受当前节点和已访问节点的集合作为参数。</p></li><li><p>首先将当前节点标记为已访问，并输出该节点。</p></li><li><p>遍历当前节点的所有未访问过的子节点，对每个子节点进行递归调用dfs函数。</p></li><li><p>如果当前节点没有未访问过的子节点，返回上一个节点。</p></li></ol><p><strong>代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10005</span>; <span class="comment">// 最大节点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; graph[MAXN]; <span class="comment">// 邻接表表示图</span></span><br><span class="line"><span class="type">bool</span> visited[MAXN]; <span class="comment">// 记录节点是否已被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// 定义一个队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(start); <span class="comment">// 将起始节点加入队列</span></span><br><span class="line">    visited[start] = <span class="literal">true</span>; <span class="comment">// 标记起始节点已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">// 只要队列不为空就继续循环</span></span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>(); <span class="comment">// 取出队头节点</span></span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">// 弹出队头节点</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; cur &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将未访问过的邻居节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[cur].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> neighbor = graph[cur][i];</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>; <span class="comment">// 标记节点已访问</span></span><br><span class="line">                q.<span class="built_in">push</span>(neighbor); <span class="comment">// 将邻居节点加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="comment">// 输入节点数和边数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入m条边，构建邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; <span class="comment">// 输入一条边的两个端点</span></span><br><span class="line">        graph[u].<span class="built_in">push_back</span>(v); <span class="comment">// 添加一条u-&gt;v的边</span></span><br><span class="line">        graph[v].<span class="built_in">push_back</span>(u); <span class="comment">// 添加一条v-&gt;u的边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点1开始进行BFS遍历</span></span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归实现DFS"><a href="#非递归实现DFS" class="headerlink" title="非递归实现DFS"></a>非递归实现DFS</h3><p><strong>实现步骤：</strong></p><ol><li>定义一个布尔型数组visited，记录每个节点是否已经被访问过；</li><li>将起始节点的序号或指针<strong>入栈</strong>，并将其对应的<strong>visited值置为true</strong>；</li><li>循环执行以下操作：<ol><li>判断栈是否为空，若为空则结束循环；</li><li>取出栈顶元素，并访问该节点；</li><li>遍历该节点的所有邻居节点，若该邻居节点未被访问过，则将其序号或指针入栈，并将对应的visited值置为true；</li></ol></li><li>重复以上步骤，直到栈为空</li></ol><p><strong>代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>; <span class="comment">// 最大节点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; graph[MAXN]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="type">bool</span> visited[MAXN]; <span class="comment">// 标记节点是否访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(start); <span class="comment">// 先把起点压入栈中</span></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = s.<span class="built_in">top</span>(); <span class="comment">// 取出栈顶元素</span></span><br><span class="line">        s.<span class="built_in">pop</span>(); <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (visited[cur]) <span class="keyword">continue</span>; <span class="comment">// 如果当前节点已经访问过了，就继续弹出下一个节点</span></span><br><span class="line">        visited[cur] = <span class="literal">true</span>; <span class="comment">// 标记当前节点已经被访问过</span></span><br><span class="line">        cout &lt;&lt; cur &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出当前节点的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = graph[cur].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从后往前遍历邻接表</span></span><br><span class="line">            <span class="type">int</span> next = graph[cur][i]; <span class="comment">// 取出下一个邻居节点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[next]) s.<span class="built_in">push</span>(next); <span class="comment">// 如果下一个邻居节点还没有访问过，就将其压入栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="comment">// 输入节点数和边数</span></span><br><span class="line">    <span class="comment">// 输入m条边，构建邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; <span class="comment">// 输入一条边的两个端点</span></span><br><span class="line">        graph[u].<span class="built_in">push_back</span>(v); <span class="comment">// 添加一条u-&gt;v的边</span></span><br><span class="line">        graph[v].<span class="built_in">push_back</span>(u); <span class="comment">// 添加一条v-&gt;u的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    cin &gt;&gt; start; <span class="comment">// 输入起点</span></span><br><span class="line">    <span class="built_in">dfs</span>(start); <span class="comment">// 从起点开始进行DFS遍历</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS的时间复杂度"><a href="#DFS的时间复杂度" class="headerlink" title="DFS的时间复杂度"></a>DFS的时间复杂度</h3><p>DFS 的时间复杂度是 <strong>O(N+M)<strong>，其中 <strong>N</strong> 表示节点数，</strong>M</strong> 表示边数。这个复杂度的计算方式是基于以下两点：</p><ol><li>每个节点最多被访问一次。</li><li>每个边最多被访问一次。</li></ol><p>因此，遍历整个图需要的时间复杂度为 O(N+M)。</p><p>DFS 的时间复杂度可以理解为每个节点和每条边被访问的总次数之和，每个节点最多被访问一次，每条边也最多被访问一次，因此总的访问次数就是 N+M。所以，DFS 的时间复杂度为 O(N+M)。</p><h2 id="BFS的实现"><a href="#BFS的实现" class="headerlink" title="BFS的实现"></a>BFS的实现</h2><p><strong>BFS</strong>全称为“广度优先搜索”，它是一种用于遍历或搜索树或图的算法。其基本思路是从图的一个顶点开始，广度优先地遍历整个图。具体来说，BFS从某个节点出发，依次<strong>访问其所有未被访问的邻居节点</strong>，<strong>再依次访问邻居节点的邻居节点</strong>，直到遍历完整张图为止。</p><p>BFS的基本思路可以用以下几个步骤概括：</p><ol><li>将起点入队。</li><li>从队列头部取出一个节点，将其<strong>标记为已访问</strong>。</li><li>找到该节点的所有未被访问的邻居节点，并对每个邻居节点进行如下操作：<ol><li>将该邻居节点入队。</li><li>标记该邻居节点为已访问。</li></ol></li><li>重复步骤2和3，直到队列为空。</li></ol><p>BFS的基本思路比较简单，但要正确实现BFS还需要注意一些细节问题，比如如何储存图、如何避免重复访问等。接下来将详细介绍BFS的实现过程。</p><p><strong>实现步骤：</strong></p><ol><li>定义一个布尔型数组visited，记录每个节点是否已经被访问过；</li><li>将起始节点的序号或指针<strong>入队列</strong>，并将其对应的visited值置为true；</li><li>循环执行以下操作：<ol><li>判断队列是否为空，若为空则结束循环；</li><li><strong>取出</strong>队头元素，并<strong>访问</strong>该节点；</li><li><strong>遍历</strong>该节点的所有<strong>未被访问过的邻居节点</strong>，若该邻居节点未被访问过，则将其序号或指针入队列，并将对应的visited值置为true；</li></ol></li><li>重复以上步骤，直到队列为空。</li></ol><p><strong>代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10005</span>; <span class="comment">// 最大节点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; graph[MAXN]; <span class="comment">// 邻接表表示图</span></span><br><span class="line"><span class="type">bool</span> visited[MAXN]; <span class="comment">// 记录节点是否已被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// 定义一个队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(start); <span class="comment">// 将起始节点加入队列</span></span><br><span class="line">    visited[start] = <span class="literal">true</span>; <span class="comment">// 标记起始节点已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">// 只要队列不为空就继续循环</span></span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>(); <span class="comment">// 取出队头节点</span></span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">// 弹出队头节点</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; cur &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将未访问过的邻居节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[cur].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> neighbor = graph[cur][i];</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>; <span class="comment">// 标记节点已访问</span></span><br><span class="line">                q.<span class="built_in">push</span>(neighbor); <span class="comment">// 将邻居节点加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="comment">// 输入节点数和边数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入m条边，构建邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; <span class="comment">// 输入一条边的两个端点</span></span><br><span class="line">        graph[u].<span class="built_in">push_back</span>(v); <span class="comment">// 添加一条u-&gt;v的边</span></span><br><span class="line">        graph[v].<span class="built_in">push_back</span>(u); <span class="comment">// 添加一条v-&gt;u的边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点1开始进行BFS遍历</span></span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS的时间复杂度"><a href="#BFS的时间复杂度" class="headerlink" title="BFS的时间复杂度"></a>BFS的时间复杂度</h3><p>和DFS相同理解</p><h3 id="DFS和BFS时间复杂度的比较（GPT的回答"><a href="#DFS和BFS时间复杂度的比较（GPT的回答" class="headerlink" title="DFS和BFS时间复杂度的比较（GPT的回答"></a>DFS和BFS时间复杂度的比较（GPT的回答</h3><p><strong>分几种情况：</strong></p><ol><li>对于一个有N个节点、M条边的图而言，BFS和DFS都需要访问每个节点和每条边一次，因此它们的时间复杂度都是O(N+M)。在这种情况下，BFS和DFS的时间复杂度是相同的。</li><li>当图是一个稠密图（E~V^2）时，BFS的时间复杂度可能会高于DFS，因为BFS需要维护一个队列，并且需要遍历所有的邻居节点。而DFS只需要维护一个栈，所以空间复杂度较小，更容易实现。</li><li>在一个深度很大的树中，DFS可能需要遍历整个深度，而BFS只需要遍历每个节点的子节点。因此，在这种情况下，DFS的时间复杂度可能会高于BFS。</li></ol><h2 id="一些要注意的点"><a href="#一些要注意的点" class="headerlink" title="一些要注意的点"></a>一些要注意的点</h2><p><strong>节点是否已经被访问过</strong>：在遍历过程中，需要记录每个节点是否已经被访问过，避免重复访问同一节点，造成死循环。在DFS中，可以使用一个布尔型数组visited记录每个节点是否已经被访问过，在BFS中，可以使用一个队列queue存储已访问过的节点，避免重复入队。</p><p><strong>图是否连通</strong>：DFS和BFS都是基于图的遍历算法，如果图不连通，那么有些节点可能无法被遍历到。在实际应用中，需要对图进行连通性检测，确保所有节点都能被遍历到。</p><p><strong>有向图和无向图</strong>：在有向图中，遍历方向是有限制的，需要特别注意遍历顺序。在无向图中，遍历方向没有限制，需要考虑重复遍历同一节点的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BFS和DFS是搜索算法的基础，需要熟练掌握，尽量能亲自多打几次</p><p>需要注意DFS和BFS中的细节问题，如边界情况和标记已访问节点等</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些小知识点</title>
      <link href="/posts/6153c8cd.html"/>
      <url>/posts/6153c8cd.html</url>
      
        <content type="html"><![CDATA[<h1 id="一些小知识点"><a href="#一些小知识点" class="headerlink" title="一些小知识点"></a>一些小知识点</h1><h2 id="关于输入和输出"><a href="#关于输入和输出" class="headerlink" title="关于输入和输出"></a>关于输入和输出</h2><ol><li><strong>scanf</strong> 和<strong>cin</strong><br>知识点：<br><strong>scanf</strong> 在读入的时候，不会自动过滤掉空格，制表符<br><strong>cin</strong>则自动过滤掉了</li><li><strong>fgets</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  fgets（buf，n，stdin）;</span><br><span class="line"><span class="comment">//buf:这是指向一个字符数组的指针，该数组存储了要读取的字符串</span></span><br><span class="line"><span class="comment">//n:这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度</span></span><br><span class="line"><span class="comment">//stdin</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h2><ol><li><p>循环n次的一个简单方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n--)&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>简单斐波那契</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">     cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">     <span class="type">int</span> c = a + b;</span><br><span class="line">     a = b;</span><br><span class="line">     b = c;</span><br><span class="line">   &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>循环在时间复杂度方面的一个优化</p><p><strong>例题：</strong><br>一个整数，除了本身以外的其他所有约数的和如果等于该数，那么我们就称这个整数为完全数。</p><p>例如，6 就是一个完全数，因为它的除了本身以外的其他约数的和为 1+2+3&#x3D;6。</p><p>现在，给定你 <strong>N</strong> 个整数，请你依次判断这些数是否是完全数。 </p><p><strong>输入格式</strong><br>第一行包含整数 N，表示共有 N 个测试用例。</p><p>接下来 N 行，每行包含一个需要你进行判断的整数 X。</p><p><strong>输出格式</strong><br>每个测试用例输出一个结果，每个结果占一行。</p><p>如果测试数据是完全数，则输出 <em>X is perfect</em>，其中 X 是测试数据。</p><p>如果测试数据不是完全数，则输出 <em>X is not perfect</em>，其中 X 是测试数据。</p><p><strong>数据范围</strong><br>1≤N≤100,<br>1≤X≤108</p></li></ol>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> N;</span><br><span class="line">  cin&gt;&gt;N;</span><br><span class="line">  <span class="keyword">while</span>(N--)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> m ,sum=<span class="number">0</span>;</span><br><span class="line">      cin&gt;&gt;m;</span><br><span class="line">      <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d is not perfect\n&quot;</span>,m);</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">      &#123;</span><br><span class="line">          sum+=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(m);i++) <span class="keyword">if</span>(m%i==<span class="number">0</span>) </span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">int</span> n=m/i;<span class="comment">//做除后的另一个约数</span></span><br><span class="line">          <span class="keyword">if</span>(n==i) sum+=i;<span class="comment">//判断是否是开根</span></span><br><span class="line">          <span class="keyword">else</span> sum+=(i+n);</span><br><span class="line">       &#125;</span><br><span class="line">           <span class="keyword">if</span>(sum==m) <span class="built_in">printf</span>(<span class="string">&quot;%d is perfect\n&quot;</span>,m);</span><br><span class="line">           <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d is not perfect\n&quot;</span>,m);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>x</strong>本身<strong>除以一个约数</strong>往往可以<strong>得到另外一个约数</strong>，如果在这里思考下手并优化，极有可能<strong>减少至少开根号的循环量</strong></li><li>使用数学函数，<strong>sqrt</strong> 作为限制循环次数的条件，而另外一个约数则由<strong>输入数x除以当前的循环的约数</strong>，即可求<strong>得另一约数</strong><br>注：此处需要考虑等于的情况，比如16， 开根号是4， 4也是约数， 优化过后，复杂度为O(10^6) 100万 完全hold住</li><li>以后遇到此类题，诸如质数、完全数 等<strong>定义中带有约数、需要整除</strong>，优化方面皆可朝<strong>开平方</strong>处思考</li></ul><h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>首先是要理解数组，是一种储存数据的强而有力的手段</p><p>1. </p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/posts/d95d7e09.html"/>
      <url>/posts/d95d7e09.html</url>
      
        <content type="html"><![CDATA[<h1 id="这是我的第一篇博客"><a href="#这是我的第一篇博客" class="headerlink" title="这是我的第一篇博客"></a>这是我的第一篇博客</h1><h2 id="二级标题测试"><a href="#二级标题测试" class="headerlink" title="二级标题测试"></a>二级标题测试</h2><h3 id="三级标题测试"><a href="#三级标题测试" class="headerlink" title="三级标题测试"></a>三级标题测试</h3><p>你好<br>换行</p><h1 id="新起"><a href="#新起" class="headerlink" title="新起"></a>新起</h1><p>斜体<em>文字两边加上</em><br>一个* 或者CTRL+I<br>加粗<strong>文字两边加上</strong><br>两个* 或者CTRL+B</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>1+.+空格（列表）</li><li>回车后向下扩<ol><li>二级<ol><li>Tab加列表级</li></ol></li></ol></li></ol><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>这是一个<a href="https://ntdzyy.github.io/">链接</a><br>直接将地址复制到想加链接的文字上即可</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br></pre></td></tr></table></figure><p>三个小 &#96; 括住代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
